###~~~~~~~~~~~~~~~~###
### FPATH.ZSH FILE ###
###~~~~~~~~~~~~~~~~###
#add each topic folder to fpath so that they can add functions and completion scripts
for topic_folder ($ZSH/*) if [ -d $topic_folder ]; then  fpath=($topic_folder $fpath); fi;

#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~~~~###
### FUNCTIONS.ZSH FILE ###
###~~~~~~~~~~~~~~~~~~~~###
# up
function up_widget() {
	BUFFER="cd .."
	zle accept-line
}
zle -N up_widget
bindkey "^k" up_widget

# git
function git_prepare() {
	if [ -n "$BUFFER" ];
	then
		BUFFER="git add -A; git commit -m \"$BUFFER\" && git push"
	fi

	if [ -z "$BUFFER" ];
	then
		BUFFER="git add -A; git commit -v && git push"
	fi
				
	zle accept-line
}
zle -N git_prepare
bindkey "^g" git_prepare

# home
function goto_home() { 
	BUFFER="cd ~/"$BUFFER
	zle end-of-line
	zle accept-line
}
zle -N goto_home
bindkey "^h" goto_home

# Edit and rerun
function edit_and_run() {
	BUFFER="fc"
	zle accept-line
}
zle -N edit_and_run
bindkey "^v" edit_and_run

# LS
function ctrl_l() {
	BUFFER="ls"
	zle accept-line
}
zle -N ctrl_l
bindkey "^l" ctrl_l

# Enter
function enter_line() {
	zle accept-line
}
zle -N enter_line
bindkey "^o" enter_line

# Sudo
function add_sudo() {
	BUFFER="sudo "$BUFFER
	zle end-of-line
}
zle -N add_sudo
bindkey "^s" add_sudo

# Fix for arrow-key searching
# start typing + [Up-Arrow] - fuzzy find history forward
if [[ "${terminfo[kcuu1]}" != "" ]]; then
	autoload -U up-line-or-beginning-search
	zle -N up-line-or-beginning-search
	bindkey "${terminfo[kcuu1]}" up-line-or-beginning-search
fi

# start typing + [Down-Arrow] - fuzzy find history backward
if [[ "${terminfo[kcud1]}" != "" ]]; then
	autoload -U down-line-or-beginning-search
	zle -N down-line-or-beginning-search
	bindkey "${terminfo[kcud1]}" down-line-or-beginning-search
fi

c() {
	cd $1;
	ls;
}
alias cd="c"

#compdef _tmuxinator tmuxinator

_tmuxinator() {
  local commands projects
  commands=(${(f)"$(tmuxinator commands zsh)"})
  projects=(${(f)"$(tmuxinator completions start)"})

  if (( CURRENT == 2 )); then
    _alternative \
      'commands:: _describe -t commands "tmuxinator subcommands" commands' \
      'projects:: _describe -t projects "tmuxinator projects" projects'
  elif (( CURRENT == 3)); then
    case $words[2] in
      copy|cp|c|debug|delete|rm|open|o|start|s|edit|e)
        _arguments '*:projects:($projects)'
      ;;
    esac
  fi

  return
}


# Local Variables:
# mode: Shell-Script
# sh-indentation: 2
# indent-tabs-mode: nil
# sh-basic-offset: 2
# End:
# vim: ft=zsh sw=2 ts=2 et


#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~###
### WINDOW.ZSH FILE ###
###~~~~~~~~~~~~~~~~~###
# From http://dotfiles.org/~_why/.zshrc
# Sets the window title nicely no matter where you are
function title() {
  # escape '%' chars in $1, make nonprintables visible
  a=${(V)1//\%/\%\%}

  # Truncate command, and join lines.
  a=$(print -Pn "%40>...>$a" | tr -d "\n")

  case $TERM in
  screen)
    print -Pn "\ek$a:$3\e\\" # screen title (in ^A")
    ;;
  xterm*|rxvt)
    print -Pn "\e]2;$2\a" # plain xterm title ($3 for pwd)
    ;;
  esac
}

#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~###
### PROMPT.ZSH FILE ###
###~~~~~~~~~~~~~~~~~###
autoload colors && colors
# cheers, @ehrenmurdick
# http://github.com/ehrenmurdick/config/blob/master/zsh/prompt.zsh

if (( $+commands[git] ))
then
  git="$commands[git]"
else
  git="/usr/bin/git"
fi

git_branch() {
  echo $($git symbolic-ref HEAD 2>/dev/null | awk -F/ {'print $NF'})
}

git_dirty() {
  if $(! $git status -s &> /dev/null)
  then
    echo ""
  else
    if [[ $($git status --porcelain) == "" ]]
    then
      echo "on %{$fg_bold[green]%}$(git_prompt_info)%{$reset_color%}"
    else
      echo "on %{$fg_bold[red]%}$(git_prompt_info)%{$reset_color%}"
    fi
  fi
}

git_prompt_info () {
 ref=$($git symbolic-ref HEAD 2>/dev/null) || return
# echo "(%{\e[0;33m%}${ref#refs/heads/}%{\e[0m%})"
 echo "${ref#refs/heads/}"
}

# This assumes that you always have an origin named `origin`, and that you only
# care about one specific origin. If this is not the case, you might want to use
# `$git cherry -v @{upstream}` instead.
need_push () {
  if [ $($git rev-parse --is-inside-work-tree 2>/dev/null) ]
  then
    number=$($git cherry -v origin/$(git symbolic-ref --short HEAD) 2>/dev/null | wc -l | bc)

    if [[ $number == 0 ]]
    then
      echo " "
    else
      echo " with %{$fg_bold[magenta]%}$number unpushed%{$reset_color%}"
    fi
  fi
}

directory_name() {
  echo "%{$fg_bold[cyan]%}%1/%\/%{$reset_color%}"
}

battery_status() {
  if test ! "$(uname)" = "Darwin"
  then
    exit 0
  fi

  if [[ $(sysctl -n hw.model) == *"Book"* ]]
  then
    $ZSH/bin/battery-status
  fi
}

export PROMPT=$'\n$(battery_status)in $(directory_name) $(git_dirty)$(need_push)\n› '
set_prompt () {
  export RPROMPT="%{$fg_bold[cyan]%}%{$reset_color%}"
}

precmd() {
  title "zsh" "%m" "%55<...<%~"
  set_prompt
}
#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~~~~~###
### COMPLETION.ZSH FILE ###
###~~~~~~~~~~~~~~~~~~~~~###
# matches case insensitive for lowercase
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# pasting with tabs doesn't perform completion
zstyle ':completion:*' insert-tab pending
#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~~###
### ALIASES.ZSH FILE ###
###~~~~~~~~~~~~~~~~~~###
export ZSH=$HOME"/.oh-my-zsh"
export PATH=$PATH:/home/josegois/Github/flutter/bin

alias reload!='. ~/.zshrc'

alias vs="v `git status --porcelain | sed -ne 's/^ M //p'`"
alias v="vim -p"
alias cd="c"
alias vrc='vim $DOTPATH/vim/vimrc.vim'
alias yoda01_jupyter="sudo docker run -it -p 8443:8888 -v /home/zetdg/data:/home/jovyan -v /home/zetdg/notebook:/home/jovyan/notebook -v /mnt/nfs/dados_nas/proc:/home/jovyan/proc -v /mnt/nfs/dados_nas/raw:/home/jovyan/raw -v /mnt/nfs/dados_nas/digest:/home/jovyan/digest -v /mnt/nfs/dados_nas/report:/home/jovyan/report -e NB_UID=1000 -e NB_GID=100 -e GRANT_SUDO=yes jupyter/datascience-notebook start-notebook.sh --NotebookApp.token=''"
alias vdoc='cd ~/doutorado && vtex ~/doutorado/main.tex'
alias ssh_yoda1="ssh -X -L 8888:yoda01.neuro.ufrn.br:8443 zetdg@yoda01.neuro.ufrn.br -p2222 -t 'tmux a -t Generic || tmux new -s Generic'"
alias ssh_yoda="ssh -X -L 8888:177.20.140.1:8443 zetdg@177.20.140.1 -p2222 -t 'tmux a -t Generic || tmux new -s Generic'"
alias cls='clear' # Good 'ol Clear Screen command

#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~###
### CONFIG.ZSH FILE ###
###~~~~~~~~~~~~~~~~~###
export LSCOLORS="exfxcxdxbxegedabagacad"
export CLICOLOR=true
export VISUAL=nvim
fpath=($ZSH/functions $fpath)

#autoload -U $ZSH/functions/*(:t)

HISTFILE=~/.zsh_history
HISTSIZE=1000000
SAVEHIST=1000000

setopt NO_BG_NICE # don't nice background tasks
setopt NO_HUP
setopt NO_LIST_BEEP
setopt LOCAL_OPTIONS # allow functions to have local options
setopt LOCAL_TRAPS # allow functions to have local traps
setopt HIST_VERIFY
setopt SHARE_HISTORY # share history between sessions ???
setopt EXTENDED_HISTORY # add timestamps to history
setopt PROMPT_SUBST
setopt CORRECT
setopt COMPLETE_IN_WORD
setopt IGNORE_EOF

setopt APPEND_HISTORY # adds history
setopt INC_APPEND_HISTORY SHARE_HISTORY  # adds history incrementally and share it across sessions
setopt HIST_IGNORE_ALL_DUPS  # don't record dupes in history
setopt HIST_REDUCE_BLANKS

# don't expand aliases _before_ completion has finished
#   like: git comm-[tab]
setopt complete_aliases

bindkey '^[^[[D' backward-word
bindkey '^[^[[C' forward-word
bindkey '^[[5D' beginning-of-line
bindkey '^[[5C' end-of-line
bindkey '^[[3~' delete-char
bindkey '^?' backward-delete-char
#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~

###~~~~~~~~~~~~~~~~~~###
### COMMENT.ZSH FILE ###
###~~~~~~~~~~~~~~~~~~###
### # If you come from bash you might have to change your $PATH.
### # export PATH=$HOME/bin:/usr/local/bin:$PATH
### 
### # Path to your oh-my-zsh installation.
### ## ENVIRONMENT VARIABLES
### 
### 
### export ZSH=$HOME"/.oh-my-zsh"
### export PATH=$PATH:/home/josegois/Github/flutter/bin
### #export CURRENT_PWD=$(pwd)
### #export PREVIOUS_PWD=${PREVIOUS_PWD:-${CURRENT_PWD}}
### #cd (){
### #	echo "Previous was $PREVIOUS_PWD"
### #	echo "Current is $CURRENT_PWD"
### #
### #	builtin cd "$1"
### #
### ##	if ( $PREVIOUS_PWD != $CURRENT_PWD ); then
### ##		echo "Previous was $PREVIOUS_PWD"
### ##		echo "Current is $CURRENT_PWD"
### ##	fi
### #
### #
### #	PREVIOUS_PWD=$CURRENT_PWD
### #	CURRENT_PWD=$(pwd)
### #}
### # Set name of the theme to load --- if set to "random", it will
### # load a random theme each time oh-my-zsh is loaded, in which case,
### # to know which specific one was loaded, run: echo $RANDOM_THEME
### # See https://github.com/ohmyzsh/ohmyzsh/wiki/Themes
### #ZSH_THEME="robbyrussell"
### #ZSH_THEME="bureau"
### 
### ## ALIAS LIST
### 
### #	alias vim="nvim"
### #	alias vimdiff="nvim -d"
### 
### # Set list of themes to pick from when loading at random
### # Setting this variable when ZSH_THEME=random will cause zsh to load
### # a theme from this variable instead of looking in ~/.oh-my-zsh/themes/
### # If set to an empty array, this variable will have no effect.
### # ZSH_THEME_RANDOM_CANDIDATES=( "robbyrussell" "agnoster" )
### 
### # Uncomment the following line to use case-sensitive completion.
### # CASE_SENSITIVE="true"
### 
### # Uncomment the following line to use hyphen-insensitive completion.
### # Case-sensitive completion must be off. _ and - will be interchangeable.
### # HYPHEN_INSENSITIVE="true"
### 
### # Uncomment the following line to disable bi-weekly auto-update checks.
### # DISABLE_AUTO_UPDATE="true"
### 
### # Uncomment the following line to automatically update without prompting.
### # DISABLE_UPDATE_PROMPT="true"
### 
### # Uncomment the following line to change how often to auto-update (in days).
### # export UPDATE_ZSH_DAYS=13
### 
### # Uncomment the following line if pasting URLs and other text is messed up.
### # DISABLE_MAGIC_FUNCTIONS=true
### 
### # Uncomment the following line to disable colors in ls.
### # DISABLE_LS_COLORS="true"
### 
### # Uncomment the following line to disable auto-setting terminal title.
### # DISABLE_AUTO_TITLE="true"
### 
### # Uncomment the following line to enable command auto-correction.
### # ENABLE_CORRECTION="true"
### 
### # Uncomment the following line to display red dots whilst waiting for completion.
### # COMPLETION_WAITING_DOTS="true"
### 
### # Uncomment the following line if you want to disable marking untracked files
### # under VCS as dirty. This makes repository status check for large repositories
### # much, much faster.
### # DISABLE_UNTRACKED_FILES_DIRTY="true"
### 
### # Uncomment the following line if you want to change the command execution time
### # stamp shown in the history command output.
### # You can set one of the optional three formats:
### # "mm/dd/yyyy"|"dd.mm.yyyy"|"yyyy-mm-dd"
### # or set a custom format using the strftime function format specifications,
### # see 'man strftime' for details.
### # HIST_STAMPS="mm/dd/yyyy"
### 
### # Would you like to use another custom folder than $ZSH/custom?
### # ZSH_CUSTOM=/path/to/new-custom-folder
### 
### # Which plugins would you like to load?
### # Standard plugins can be found in ~/.oh-my-zsh/plugins/*
### # Custom plugins may be added to ~/.oh-my-zsh/custom/plugins/
### # Example format: plugins=(rails git textmate ruby lighthouse)
### # Add wisely, as too many plugins slow down shell startup.
### plugins=(git)
### 
### source $ZSH/oh-my-zsh.sh
### 
### # User configuration
### 
### # export MANPATH="/usr/local/man:$MANPATH"
### 
### # You may need to manually set your language environment
### # export LANG=en_US.UTF-8
### 
### # Preferred editor for local and remote sessions
### # if [[ -n $SSH_CONNECTION ]]; then
### #   export EDITOR='vim'
### # else
### #   export EDITOR='mvim'
### # fi
### 
### # Compilation flags
### # export ARCHFLAGS="-arch x86_64"
### 
### # Set personal aliases, overriding those provided by oh-my-zsh libs,
### # plugins, and themes. Aliases can be placed here, though oh-my-zsh
### # users are encouraged to define aliases within the ZSH_CUSTOM folder.
### # For a full list of active aliases, run `alias`.
### #
### # Example aliases
### # alias zshconfig="mate ~/.zshrc"
### # alias ohmyzsh="mate ~/.oh-my-zsh"
### #
### #
### # INITIATE A NEW CONFIGURATION
### # Filename:      /etc/skel/.zshrc
### # Purpose:       config file for zsh (z shell)
### # Authors:       (c) grml-team (grml.org)
### # Bug-Reports:   see http://grml.org/bugs/
### # License:       This file is licensed under the GPL v2 or any later version.
### ################################################################################
### # Nowadays, grml's zsh setup lives in only *one* zshrc file.
### # That is the global one: /etc/zsh/zshrc (from grml-etc-core).
### # It is best to leave *this* file untouched and do personal changes to
### # your zsh setup via ${HOME}/.zshrc.local which is loaded at the end of
### # the global zshrc.
### #
### # That way, we enable people on other operating systems to use our
### # setup, too, just by copying our global zshrc to their ${HOME}/.zshrc.
### # Adjustments would still go to the .zshrc.local file.
### ################################################################################
### 
### ## Inform users about upgrade path for grml's old zshrc layout, assuming that:
### ## /etc/skel/.zshrc was installed as ~/.zshrc,
### ## /etc/zsh/zshrc was installed as ~/.zshrc.global and
### ## ~/.zshrc.local does not exist yet.
### if [ -r ~/.zshrc -a -r ~/.zshrc.global -a ! -r ~/.zshrc.local ] ; then
###     printf '-!-\n'
###     printf '-!- Looks like you are using the old zshrc layout of grml.\n'
###     printf '-!- Please read the notes in the grml-zsh-refcard, being'
###     printf '-!- available at: http://grml.org/zsh/\n'
###     printf '-!-\n'
###     printf '-!- If you just want to get rid of this warning message execute:\n'
###     printf '-!-        touch ~/.zshrc.local\n'
###     printf '-!-\n'
### fi
### 
### ## Settings for umask
### #if (( EUID == 0 )); then
### #    umask 002
### #else
### #    umask 022
### #fi
### 
### ## Now, we'll give a few examples of what you might want to use in your
### ## .zshrc.local file (just copy'n'paste and uncomment it there):
### 
### ## Prompt theme extension ##
### 
### # Virtualenv support
### 
### #function virtual_env_prompt () {
### #    REPLY=${VIRTUAL_ENV+(${VIRTUAL_ENV:t}) }
### #}
### #grml_theme_add_token  virtual-env -f virtual_env_prompt '%F{magenta}' '%f'
### #zstyle ':prompt:grml:left:setup' items rc virtual-env change-root user at host path vcs percent
### 
### ## ZLE tweaks ##
### 
### ## use the vi navigation keys (hjkl) besides cursor keys in menu completion
### #bindkey -M menuselect 'h' vi-backward-char        # left
### #bindkey -M menuselect 'k' vi-up-line-or-history   # up
### #bindkey -M menuselect 'l' vi-forward-char         # right
### #bindkey -M menuselect 'j' vi-down-line-or-history # bottom
### 
### ## set command prediction from history, see 'man 1 zshcontrib'
### #is4 && zrcautoload predict-on && \
### #zle -N predict-on         && \
### #zle -N predict-off        && \
### #bindkey "^X^Z" predict-on && \
### #bindkey "^Z" predict-off
### 
### ## press ctrl-q to quote line:
### #mquote () {
### #      zle beginning-of-line
### #      zle forward-word
### #      # RBUFFER="'$RBUFFER'"
### #      RBUFFER=${(q)RBUFFER}
### #      zle end-of-line
### #}
### #zle -N mquote && bindkey '^q' mquote
### 
### ## define word separators (for stuff like backward-word, forward-word, backward-kill-word,..)
### #WORDCHARS='*?_-.[]~=/&;!#$%^(){}<>' # the default
### #WORDCHARS=.
### #WORDCHARS='*?_[]~=&;!#$%^(){}'
### #WORDCHARS='${WORDCHARS:s@/@}'
### 
### # just type '...' to get '../..'
### #rationalise-dot() {
### #local MATCH
### #if [[ $LBUFFER =~ '(^|/| |	|'$'\n''|\||;|&)\.\.$' ]]; then
### #  LBUFFER+=/
### #  zle self-insert
### #  zle self-insert
### #else
### #  zle self-insert
### #fi
### #}
### #zle -N rationalise-dot
### #bindkey . rationalise-dot
### ## without this, typing a . aborts incremental history search
### #bindkey -M isearch . self-insert
### 
### #bindkey '\eq' push-line-or-edit
### 
### ## some popular options ##
### 
### ## add `|' to output redirections in the history
### #setopt histallowclobber
### 
### ## try to avoid the 'zsh: no matches found...'
### #setopt nonomatch
### 
### ## warning if file exists ('cat /dev/null > ~/.zshrc')
### #setopt NO_clobber
### 
### ## don't warn me about bg processes when exiting
### #setopt nocheckjobs
### 
### ## alert me if something failed
### #setopt printexitvalue
### 
### ## with spelling correction, assume dvorak kb
### #setopt dvorak
### 
### ## Allow comments even in interactive shells
### #setopt interactivecomments
### 
### 
### ## compsys related snippets ##
### 
### ## changed completer settings
### #zstyle ':completion:*' completer _complete _correct _approximate
### #zstyle ':completion:*' expand prefix suffix
### 
### ## another different completer setting: expand shell aliases
### #zstyle ':completion:*' completer _expand_alias _complete _approximate
### 
### ## to have more convenient account completion, specify your logins:
### #my_accounts=(
### # {grml,grml1}@foo.invalid
### # grml-devel@bar.invalid
### #)
### #other_accounts=(
### # {fred,root}@foo.invalid
### # vera@bar.invalid
### #)
### #zstyle ':completion:*:my-accounts' users-hosts $my_accounts
### #zstyle ':completion:*:other-accounts' users-hosts $other_accounts
### 
### ## add grml.org to your list of hosts
### #hosts+=(grml.org)
### #zstyle ':completion:*:hosts' hosts $hosts
### 
### ## telnet on non-default ports? ...well:
### ## specify specific port/service settings:
### #telnet_users_hosts_ports=(
### #  user1@host1:
### #  user2@host2:
### #  @mail-server:{smtp,pop3}
### #  @news-server:nntp
### #  @proxy-server:8000
### #)
### #zstyle ':completion:*:*:telnet:*' users-hosts-ports $telnet_users_hosts_ports
### 
### ## the default grml setup provides '..' as a completion. it does not provide
### ## '.' though. If you want that too, use the following line:
### #zstyle ':completion:*' special-dirs true
### 
### ## aliases ##
### 
### ## translate
### #alias u='translate -i'
### 
### ## ignore ~/.ssh/known_hosts entries
### #alias insecssh='ssh -o "StrictHostKeyChecking=no" -o "UserKnownHostsFile=/dev/null" -o "PreferredAuthentications=keyboard-interactive"'
### 
### 
### ## global aliases (for those who like them) ##
### 
### #alias -g '...'='../..'
### #alias -g '....'='../../..'
### #alias -g BG='& exit'
### #alias -g C='|wc -l'
### #alias -g G='|grep'
### #alias -g H='|head'
### #alias -g Hl=' --help |& less -r'
### #alias -g K='|keep'
### #alias -g L='|less'
### #alias -g LL='|& less -r'
### #alias -g M='|most'
### #alias -g N='&>/dev/null'
### #alias -g R='| tr A-z N-za-m'
### #alias -g SL='| sort | less'
### #alias -g S='| sort'
### #alias -g T='|tail'
### #alias -g V='| vim -'
### 
### ## instead of global aliase it might be better to use grmls $abk assoc array, whose contents are expanded after pressing ,.
### #$abk[SnL]="| sort -n | less"
### 
### ## get top 10 shell commands:
### #alias top10='print -l ${(o)history%% *} | uniq -c | sort -nr | head -n 10'
### 
### ## Execute \kbd{./configure}
### #alias CO="./configure"
### 
### ## Execute \kbd{./configure --help}
### #alias CH="./configure --help"
### 
### ## miscellaneous code ##
### 
### ## Use a default width of 80 for manpages for more convenient reading
### #export MANWIDTH=${MANWIDTH:-80}
### 
### ## Set a search path for the cd builtin
### #cdpath=(.. ~)
### 
### ## variation of our manzsh() function; pick you poison:
### #manzsh()  { /usr/bin/man zshall |  most +/"$1" ; }
### 
### ## Switching shell safely and efficiently? http://www.zsh.org/mla/workers/2001/msg02410.html
### #bash() {
### #    NO_SWITCH="yes" command bash "$@"
### #}
### #restart () {
### #    exec $SHELL $SHELL_ARGS "$@"
### #}
### 
### ## Handy functions for use with the (e::) globbing qualifier (like nt)
### #contains() { grep -q "$*" $REPLY }
### #sameas() { diff -q "$*" $REPLY &>/dev/null }
### #ot () { [[ $REPLY -ot ${~1} ]] }
### 
### ## get_ic() - queries imap servers for capabilities; real simple. no imaps
### #ic_get() {
### #    emulate -L zsh
### #    local port
### #    if [[ ! -z $1 ]] ; then
### #        port=${2:-143}
### #        print "querying imap server on $1:${port}...\n";
### #        print "a1 capability\na2 logout\n" | nc $1 ${port}
### #    else
### #        print "usage:\n  $0 <imap-server> [port]"
### #    fi
### #}
### 
### ## List all occurrences of programm in current PATH
### #plap() {
### #    emulate -L zsh
### #    if [[ $# = 0 ]] ; then
### #        echo "Usage:    $0 program"
### #        echo "Example:  $0 zsh"
### #        echo "Lists all occurrences of program in the current PATH."
### #    else
### #        ls -l ${^path}/*$1*(*N)
### #    fi
### #}
### 
### ## Find out which libs define a symbol
### #lcheck() {
### #    if [[ -n "$1" ]] ; then
### #        nm -go /usr/lib/lib*.a 2>/dev/null | grep ":[[:xdigit:]]\{8\} . .*$1"
### #    else
### #        echo "Usage: lcheck <function>" >&2
### #    fi
### #}
### 
### ## Download a file and display it locally
### #uopen() {
### #    emulate -L zsh
### #    if ! [[ -n "$1" ]] ; then
### #        print "Usage: uopen \$URL/\$file">&2
### #        return 1
### #    else
### #        FILE=$1
### #        MIME=$(curl --head $FILE | \
### #               grep Content-Type | \
### #               cut -d ' ' -f 2 | \
### #               cut -d\; -f 1)
### #        MIME=${MIME%$'\r'}
### #        curl $FILE | see ${MIME}:-
### #    fi
### #}
### 
### ## Memory overview
### #memusage() {
### #    ps aux | awk '{if (NR > 1) print $5;
### #                   if (NR > 2) print "+"}
### #                   END { print "p" }' | dc
### #}
### 
### ## print hex value of a number
### #hex() {
### #    emulate -L zsh
### #    if [[ -n "$1" ]]; then
### #        printf "%x\n" $1
### #    else
### #        print 'Usage: hex <number-to-convert>'
### #        return 1
### #    fi
### #}
### 
### ## log out? set timeout in seconds...
### ## ...and do not log out in some specific terminals:
### #if [[ "${TERM}" == ([Exa]term*|rxvt|dtterm|screen*) ]] ; then
### #    unset TMOUT
### #else
### #    TMOUT=1800
### #fi
### 
### ## associate types and extensions (be aware with perl scripts and anwanted behaviour!)
### #check_com zsh-mime-setup || { autoload zsh-mime-setup && zsh-mime-setup }
### #alias -s pl='perl -S'
### 
### ## ctrl-s will no longer freeze the terminal.
### #stty erase "^?"
### 
### ## you want to automatically use a bigger font on big terminals?
### #if [[ "$TERM" == "xterm" ]] && [[ "$LINES" -ge 50 ]] && [[ "$COLUMNS" -ge 100 ]] && [[ -z "$SSH_CONNECTION" ]] ; then
### #    large
### #fi
### 
### ## Some quick Perl-hacks aka /useful/ oneliner
### #bew() { perl -le 'print unpack "B*","'$1'"' }
### #web() { perl -le 'print pack "B*","'$1'"' }
### #hew() { perl -le 'print unpack "H*","'$1'"' }
### #weh() { perl -le 'print pack "H*","'$1'"' }
### #pversion()    { perl -M$1 -le "print $1->VERSION" } # i. e."pversion LWP -> 5.79"
### #getlinks ()   { perl -ne 'while ( m/"((www|ftp|http):\/\/.*?)"/gc ) { print $1, "\n"; }' $* }
### #gethrefs ()   { perl -ne 'while ( m/href="([^"]*)"/gc ) { print $1, "\n"; }' $* }
### #getanames ()  { perl -ne 'while ( m/a name="([^"]*)"/gc ) { print $1, "\n"; }' $* }
### #getforms ()   { perl -ne 'while ( m:(\</?(input|form|select|option).*?\>):gic ) { print $1, "\n"; }' $* }
### #getstrings () { perl -ne 'while ( m/"(.*?)"/gc ) { print $1, "\n"; }' $*}
### #getanchors () { perl -ne 'while ( m/«([^«»\n]+)»/gc ) { print $1, "\n"; }' $* }
### #showINC ()    { perl -e 'for (@INC) { printf "%d %s\n", $i++, $_ }' }
### #vimpm ()      { vim `perldoc -l $1 | sed -e 's/pod$/pm/'` }
### #vimhelp ()    { vim -c "help $1" -c on -c "au! VimEnter *" }
### 
### ## END OF FILE #################################################################
### #
### #
### ## JOSE GOIS MODIFICATIONS
### ## BEGIN OF EDIT!
### # Upgrade from vim to neovim
### #
### #
#~~~~~~~~~~~~~~~~~~~~
# EOF #
#~~~~~~~~~~~~~~~~~~~~
